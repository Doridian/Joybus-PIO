.program n64out

.wrap_target
wrap_target:

pull block

mov isr null
out isr 2 ; ISR now contains payload len bytes
in null 3 ; shift by 3
mov x isr ; and load to X

mov isr null
out isr 6 ; ISR now contains response len bytes
in null 3 ; shift by 3
mov y isr ; and load to Y

jmp !x skip_write

jmp x-- first_write ; plain decrement X
 ; MUST SUBTRACT 11 CYCLES
 next_write:
    set pindirs, 0 [10] ; waste 11 cycles
first_write:
    set pindirs, 1 [15] ; assert low
    out pindirs, 1 [31] ; set to target bit
    set pindirs, 0 [3] ; de-assert, skip jump cycle and cycle waster above
    jmp x-- next_write

skip_write:
jmp !y wrap_target

set pindirs, 0 [9]
; write stop-bit
set pindirs, 1 [15]
set pindirs, 0 [15]

; start read routine
mov isr null
jmp y-- next_read ; plain decrement Y
next_read:
    wait 0 pin 0 [31] ; wait for gamepad LOW assertion
    in pins 1
    wait 1 pin 0 ; wait for gamepad HIGH/release
    jmp y-- next_read
push
; fall-through to wrap_target

% c-sdk {
static inline void n64out_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_sm_set_enabled(pio, sm, false);

    gpio_set_dir(pin, GPIO_IN);
    gpio_disable_pulls(pin);
    gpio_set_oeover(pin, GPIO_OVERRIDE_HIGH);
    gpio_set_outover(pin, GPIO_OVERRIDE_LOW);

    pio_sm_config c = n64out_program_get_default_config(offset);
    sm_config_set_in_pins(&c, pin);
    sm_config_set_out_pins(&c, pin, 1);
    sm_config_set_set_pins(&c, pin, 1);

    sm_config_set_out_shift(&c, false, false, 32);
    sm_config_set_in_shift(&c, false, true, 32);
    
    float frac = (clock_get_hz(clk_sys) / 1000000) / 16;
    sm_config_set_clkdiv(&c, frac);

    pio_gpio_init(pio, pin);
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);

    pio_sm_set_enabled(pio, sm, true);
}
%}
