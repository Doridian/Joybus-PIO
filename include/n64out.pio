.program n64out
.side_set 1 opt pindirs

pull block side 0
out y, 32 ; store required delay in Y (1us)

.wrap_target
wrap_target:

pull block
out x 16
jmp !x outnext_start
out x 8
jmp !x write_single

;doread:
;in y 32 side 0
;push
;jmp wrap_target
in null 24 side 0
nextread:
    wait 0 pin 0 ; wait for gamepad LOW assertion
    mov x, y
    wtime_read:
        jmp x-- wtime_read
    mov x, y
    wtime_read2:
        jmp x-- wtime_read2
    in pins 1
    wait 1 pin 0 ; wait for gamepad HIGH/release
    out null 1
    jmp !osre nextread
push
jmp wrap_target

; output stop-bit instead of real bit
outnext_start:
out null 1
write_single:
out null 7
outnext:
    ; wait loop for Y 
    mov x, y side 1 ; assert low
    wtime1:
        jmp x-- wtime1

    ; set to low if we are on a low bit
    out pindirs 1
    ; wait loop for 2Y
    mov x, y
    wtime2:
        jmp x-- wtime2
    mov x, y
    wtime3:
        jmp x-- wtime3

    mov x, y side 0 ; de-assert to high
    wtime4:
        jmp x-- wtime4
    jmp !osre outnext

% c-sdk {
static inline void n64out_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_gpio_init(pio, pin);
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);
    pio_sm_config c = n64out_program_get_default_config(offset);
    sm_config_set_in_pins(&c, pin);
    sm_config_set_out_pins(&c, pin, 1);
    sm_config_set_set_pins(&c, pin, 1);
    sm_config_set_sideset_pins(&c, pin);

    sm_config_set_out_shift(&c, false, false, 32);
    sm_config_set_in_shift(&c, false, false, 32);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);

    pio->txf[sm] = (clock_get_hz(clk_sys) / 1000000) - 3;
}
%}
